\documentclass{llncs}
\usepackage{tikz-cd}
%\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{color}
%\usepackage{comment}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{tikz}
\usepackage[all]{xy}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{enumerate}

% \lstset{
%   basicstyle={\ttfamily},
%   identifierstyle={\small},
%   commentstyle={\smallitshape},
%   keywordstyle={\small\bfseries},
%   ndkeywordstyle={\small},
%   stringstyle={\small\ttfamily},
%   frame={tb},
%   breaklines=true,
%   columns=[l]{fullflexible},
%   numbers=left,
%   xrightmargin=0zw,
%   xleftmargin=3zw,
%   numberstyle={\scriptsize},
%   stepnumber=1,
%   numbersep=1zw,
%   lineskip=-0.5ex
% }

\newcommand{\Pow}{\mathcal{P}}
\newcommand{\Rel}{\mathrm{Rel}}
\newcommand{\Endo}{\mathrm{Endo}}
\newcommand{\Bidir}{\mathrm{Bidir}}
\newcommand{\Unidir}{\mathrm{Bwd}}
\newcommand{\Bwd}{\mathrm{Bwd}}
\newcommand{\UnidirConst}{\mathrm{BidirConst}}
\newcommand{\Backward}{\mathrm{Backward}}

\newcommand{\tomon}{\to_{\mathrm{mon}}}

\newcommand{\ff}{{f^{\rightarrow}}}
\newcommand{\fb}{{f^{\leftarrow}}}
\newcommand{\gf}{{g^{\rightarrow}}}
\newcommand{\gb}{{g^{\leftarrow}}}
\newcommand{\kf}{{k^{\rightarrow}}}
\newcommand{\kb}{{k^{\leftarrow}}}

\newcommand{\join}{\sqcup}
\newcommand{\bigjoin}{\bigsqcup}
\newcommand{\meet}{\sqcap}
\newcommand{\bigmeet}{\sqcap}

\newcommand{\comp}{\circ}
\newcommand{\starlift}{\mathbin{\overline{*}}}
\newcommand{\bowtielift}{\mathbin{\overline{\bowtie}}}
\newcommand{\caplift}{\mathbin{\overline{\cap}}}
\newcommand{\rotleq}{\rotatebox[origin=c]{90}{$\leq$}}
\newcommand{\rotsubseteq}{\rotatebox[origin=c]{90}{$\subseteq$}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\gray}[1]{\textcolor{gray}{#1}}

\newcommand{\opt}{\mathbf{o}}
\newcommand{\mnd}{\mathbf{m}}
\newcommand{\xs}{\mathit{xs}}

\newcommand{\binop}{\mathtt{binop}}
\newcommand{\binopbw}{\scalebox{0.7}{$\begin{aligned} x,x,\xs &\mapsfrom x, \xs\end\\
\star &\mapsfrom \opt\opt, \star\end{aligned}$}}
\newcommand{\binopfw}{\scalebox{0.7}{$\begin{aligned} \x,x',xs &\mapsto x, \xs\\
                                        \x,\star&\mapsto \star \\
                                      \star &\mapsto \opt,\star\end{aligned}$}}

\newcommand{\push}{\mathtt{push}}
\newcommand{\pushbw}{\scalebox{0.7}{$\begin{aligned} \xs &\mapsfrom x, \xs\end{aligned}$}}
\newcommand{\pushfw}{\scalebox{0.7}{$\begin{aligned} \xs &\mapsto x, \xs \end{aligned}$}}

\newcommand{\load}{\mathtt{load}}
\newcommand{\loadbw}{\scalebox{0.7}{$\begin{aligned} \xs &\mapsfrom x, \xs\end{aligned}$}}
\newcommand{\loadfw}{\scalebox{0.7}{$\begin{aligned} \xs &\mapsto x,\xs \end{aligned}$}}

\newcommand{\dup}{\mathtt{dup}}
\newcommand{\dupbw}{\scalebox{0.7}{$\begin{aligned} \xs &\mapsfrom x, \xs\end{aligned}$}}
\newcommand{\dupfw}{\scalebox{0.7}{$\begin{aligned} \xs &\mapsto x,\xs \end{aligned}$}}

\newcommand{\pop}{\mathtt{pop}}
\newcommand{\popbw}{\scalebox{0.7}{$\begin{aligned} \opt, \xs &\mapsfrom \xs\end{aligned}$}}
\newcommand{\popfw}{\scalebox{0.7}{$\begin{aligned} x, \xs &\mapsto \xs \end{aligned}$}}

\newcommand{\nop}{\mathtt{nop}}
\newcommand{\nopbw}{\scalebox{0.7}{$\begin{aligned} \xs &\mapsfrom \xs\end{aligned}$}}
\newcommand{\nopfw}{\scalebox{0.7}{$\begin{aligned} \xs &\mapsto \xs\end{aligned}$}}

\newcommand{\store}{\mathtt{store}}
\newcommand{\storebw}{\scalebox{0.7}{$\begin{aligned} \mnd, \xs &\mapsfrom \xs\end{aligned}$}}
\newcommand{\storefw}{\scalebox{0.7}{$\begin{aligned} x, \xs &\mapsto \xs\end{aligned}$}}

\newcommand{\print}{\mathtt{print}}
\newcommand{\printbw}{\scalebox{0.7}{$\begin{aligned} \mnd, \xs &\mapsfrom \xs\end{aligned}$}}
\newcommand{\printfw}{\scalebox{0.7}{$\begin{aligned} x, \xs &\mapsto \xs\end{aligned}$}}

\newcommand{\seq}{\mathbin{;}}
\newcommand{\choice}{\mathbin{|}}

\newcommand{\Var}{\mathsf{Var}}
\newcommand{\State}{\mathsf{State}}
\newcommand{\FV}{\mathrm{FV}}

\newcommand{\sqleq}{\sqsubseteq}

\newenvironment{subproof}[1][\proofname]{%
  \renewcommand{\qedsymbol}{$\blacksquare$}%
  \begin{proof}[#1]%
}{%
  \end{proof}%
}

\title{Bidirectional data-flow analyses compared to relational through Galois connections}
\author{
  Dylan McDermott
\and
  * Yasuaki Morita
\and
  Tarmo Uustalu
}
\institute{Reykjavik University}
\date{Wed 22 - Thu 23 November NWPT 2023 V{\"a}ster{\aa}s }

\begin{document}



\usetikzlibrary{shapes,arrows}

\tikzstyle{term}=[
  rectangle,
  text width=1.0cm,
  % draw=black,
  %fill=white,
  text centered,
]
\tikzstyle{block}=[
  rectangle,
  text width=1.2cm,
  % draw=black,
  %fill=white,
  text centered,
]

\tikzstyle{arrow}=[
  thick,->,>=stealth
]

\tikzstyle{trans}=[
  thick,=>,>=stealth
]

\tikzstyle{empty}=[
  thick,->,>=stealth
]


  
\section{Introduction}

\paragraph{Data-flow vs Relational Constraints}
Data-flow analysis
    \begin{itemize}
    \item Many applications in program analysis and compiler optimization.
    \item Information at each program point is propagated over the program by backward or forward transfer \red{functions}.
    \end{itemize}


Constraint-based analysis
    \begin{itemize}
    \item A powerful tool to test property of programs including type inference.
    \item Based on logical formula, equations, and \red{relations}.
    \end{itemize}


\section{Preliminaries: Galois connections}

In this paper, we compare different formats of data-flow analyses in
terms of Galois connections. We need the following basic definitions
and facts.

Given two partial orders $(X, \leq)$, $(Y, \leq)$, a \emph{Galois
  connection} between them is a pair of monotone functions
$\phi : X \to Y$ and $\psi : Y \to X$, called the \emph{lower} and the
\emph{upper adjoint}, such that
\[
\phi(x) \leq y \quad \mathrm{iff} \quad  x \leq \psi(y)
\]
for all $x \in X$, $y \in Y$. Equivalently, one may ask that
\[
x \leq \psi(\phi(x)) \quad \mathrm{and} \quad \phi(\psi(y)) \leq y 
\]
We write $\phi \dashv \psi$ to state this situation.

In all examples we consider here, both posets $(X, \leq)$ and
$(Y, \leq)$ are complete lattices, so have joins of all subsets and
therefore also meets. In this situation, the lower adjoint $\phi$
preserves all joins, the upper adjoint $\psi$ preserves all meets.

Galois connections are necessarily \emph{idempotent} in that one
always has
\[
\psi(y) = \psi(\phi(\psi(y))) \quad \mathrm{and} \quad \phi(\psi(\phi(x))) = \phi(x)
\]  

The set $X_0$ of fixedpoints of $\psi \circ \phi$, i.e., those
elements $x \in X$ for which $x = \psi(\phi(x))$, consists of
precisely the elements of $X$ in the image of $\psi$, i.e., $x$ such
that $x = \psi(y)$ for some $y \in Y$. This set $X_0$ is in a monotone
bijection with the set $Y_0$ of fixedpoints of $\phi \circ \psi$,
i.e., those elements of $y \in Y$ for which $\phi(\psi(y)) = y$. The
set $Y_0$ consists of precisely the elements in the image of $\phi$,
i.e., $y$ such that $\phi(x) = y$.

The monotone bijection between $X_0$ and $Y_0$ is given by just the
restrictions of $\phi$ and $\psi$ to $X_0$ and $Y_0$
respectively. Because of this isomorphism of the two posets
$(X_0, \leq)$ and $(Y_0, \leq)$, it is customary to refer to either of
them as the poset of \emph{fixedpoints} of the Galois connection.

Overall, the following picture emerges:
\[
\xymatrix{
(X, \leq)
& (Y, \leq) \\   
(X_0, \leq)
& (Y_0, \leq)
}  
\]

Given a Galois connection $\phi \dashv \psi$ between $(X, \leq)$,
$(Y, \leq)$, we sometimes want to compare two monotone binary
operations ${\otimes} : X \times X \to X$ and
${\boxtimes} : Y \times Y \to Y$. We say that $\boxtimes$
\emph{underapproximates} $\otimes$ if
\[
\psi(y_0 \boxtimes y_1) \leq \psi(y_0) \otimes \psi(y_1) 
\]  
for all $y_0, y_1 \in Y$ and that $\boxtimes$ \emph{overapproximates}
$\otimes$ if
\[
\psi(y_0) \otimes \psi(y_1) \leq \psi(y_0 \boxtimes y_1) 
\]  
Given a monotone binary operation $\otimes : X \times X \to X$, one
can always overapproximate it by the \emph{lifting} $\bar{\otimes}$
defined by
\[
y_0 \mathbin{\bar{\otimes}} y_1 = \phi(\psi(y_0) \otimes \psi(y_1)) 
\]
In fact, the lifting $\bar{\otimes}$ is always the least
overapproximation of $\otimes$. (To check, it should be??)

Similar definitions and statements hold of course also for monotone
unary operations.

The order-theoretic concept of Galois connections is a special case of
adjunctions from category theory and facts about Galois connections
generalize to adjunctions. A Galois connection between two posets is
precisely an adjunction between two thin skeletal categories (there is
at most one map between any two objects and isomorphic objects are
equal). Not every adjunction is idempotent. The fixedpoint theory of
Galois connections generalizes for idempotent adjunctions.


\section{Unidirectional analyses}

We will now apply Galois connections to study the relationship between
relational and unidirectional (specifically, backward) specification
formats of data-flow analyses. We always view the relational
specification of an analysis as its ideal version capturing all
semantically valid analysis results whereas a backward formulation
should be a version tailored to effective computation of the strongest
analysis results. We will explain what we mean by these phrases
shortly.

We assume given two complete lattices $(D, \sqleq, \bigjoin)$,
$(E, \sqleq, \bigjoin)$ that could be the data-flow value domains for
two program points in a global program (control-flow graph) connected
by a statement (edge). In usual practice, these domains would be the
same for all program points, but for now we have no reason to restrict
ourselves. They would normally also be assumed to be locally finite
(i.e., with all chains finite), but for now we do not need this
assumption either.

We are interested in the two posets $(\Pow(D \times E), \subseteq)$ and
$(E \tomon D, \sqleq)$ of \emph{binary relations} and \emph{monotone
  backward functions} between $D$ and $E$. We use the elements of
these posets as relational resp.\ backward specifications of data-flow
analyses. For brevity, we also write $\Rel(D, E)$ and $\Bwd(D, E)$
for these two posets. Both are complete lattices in fact; the first
has its joins given by unions, the second by the joins in
$(E, \sqleq, \bigjoin)$.

Between these two posets, there is a Galois connection $F \dashv G$
defined by
\begin{align*}
    F (R)(e_{0}) &= \bigjoin \{ d \mid \exists e.\, e \leq e_{0}  \land (d , e) \in R \} \\
    G (\fb) &= \{ (d , e) \mid d \leq \fb(e) \}
\end{align*}

A typical data-flow analysis that we can describe relationally and
backwardly is the live variables analysis. Here
$(D, \sqleq) = (E, \sqleq) = \Pow(\Var), \supseteq)$. For the
assignment statement $x := e$, the backward specification of the
analysis is the monotone function
$\fb (Y) = Y \setminus \{x\} \cup \FV(e)$ (returning the set of just
these variables whose values at the prepoint that can possibly affect
the values of the variables in $Y$ at the postpoint).  The relational
analysis is $R(X,Y)$ iff $X \supseteq Y \setminus \{x\} \cup \FV(e)$
(accepting any valid pre-post pair of live variable sets in the sense
of noninterference).

It is straightforward to verify that $R = G(\fb)$ and $F(R) = \fb$.  So
$R$ and $\fb$ embody, in $\Rel(D,E)$ resp. $\Bwd(D,E)$, the same
fixedpoint of the Galois connection.

Another analysis example is preconditions analysis. We might be more
used to think of it as a program logic, but its only ``flaw'' as an
analysis is that the data-flow value poset fails to be locally finite.
Here $(D, \sqleq) = (E, \sqleq) = \Pow(\State), \subseteq)$. For the
assignment statement $x := e$, the backward specification of the
analysis is the monotone function
$\fb (Q) = \{ \sigma \mid \sigma[x \mapsto \llbracket
e\rrbracket(\sigma)] \in Q \}$ (returning the weakest precondition)
while the relational specification is $R(P, Q)$ iff
$\forall \sigma.\, \sigma \in P \implies \sigma[x \mapsto \llbracket
e\rrbracket(\sigma)] \in Q$ (accepting any valid pre-postcondition
pair).

Again $R = G(\fb)$ and $F(R) = \fb$.

We say that a backward specification $\fb$ is \emph{sound} for an
analysis if $G(\fb) \subseteq R$ where $R$ is the ideal relational
specification and \emph{complete} if $G(\fb) \supseteq R$.

In the two examples we have considered, the backward specification
$\fb$ is both sound and complete.

To be able to have a sound and complete backward specification of a
relationally defined analysis, we need that any program is analyzed by
a relation within the image of $G$, i.e., in $\Rel(D,E)_0$.  A
relation $R$ turns out to be in the image of $G$ iff it is
\emph{join-closed}, i.e.,
\[
\forall S.\,  S \subseteq R \implies \bigjoin S \in R
\]  
and \emph{pre-down-post-up-closed}, i.e.,
\[
\forall d, e,d_{1 },e_{0}.\, d \leq d_{1} \land e_{0} \leq e \land
(d_{1}, e_{0}) \in R \implies (d, e) \in R
\]
or, pictorially,
\begin{center}
  \begin{tikzcd}
    d_{1} &       \\
    d     & e     \\
          & e_{0}
    \arrow["\rotleq"{name=dd1'}, from=2-1, to=1-1]
    \arrow["\rotleq"{name=e0e'}, from=3-2, to=2-2, swap]
    \arrow[""{name=r10'}, from=1-1, to=3-2, no head]
    \arrow[""{name=r'}, from=2-1, to=2-2, dashed, no head]
  \end{tikzcd}
\end{center}

(Here, we should recognize that the rules of disjunction and
subsumption are valid in Hoare logic.)

(talk about operation liftings)





Notice that our use here of Galois connections to study analyses is
unrelated to the famous one in abstract interpretation where a Galois
connection between a concrete semantics and its abstracted version (a
forward analysis) is given by abstraction and concretization
functions. There, transfer functions are endomaps on the complete
lattice $(D, \sqleq)$ of abstract states. Here, transfer functions are
elements of the complete lattice $(D \tomon D, \sqleq)$ of all
potential transfer function.


\section{Unidirectional analyses}

  \paragraph{Functions and Relations}
  How are they related?
    As a function is a certain kind of a relation,
    a data-flow analysis can be seen as a certain kind of constraint satisfaction problem, or its sound approximation.
    The notion of \emph{Galois connection} consolidates this perspective.
  
  \begin{definition}[Galois connection]
    Given posets $(X, \leq)$ and $(Y, \leq)$, a Galois connection between $(X, \leq)$ , $(Y, \leq)$ is a pair of monotone functions $F : X \tomon Y$ and $G : Y \tomon X$ such that $F(x) \leq y \iff x \leq G(y)$ for all $x \in X$ and $y \in Y$.
    We write this $F \dashv G$.
  \end{definition}

  When $F \dashv G$ is established, the following propositions hold:

  \begin{align}
    F \comp G \comp F = F \\
    G \comp F \comp G = G \\
    x \leq G(F(x)) \\
    F(G(y)) \leq y \\
    \exists y, x = G(y) \implies G(F(x)) = x \\
    \exists x, y = F(x) \implies F(G(y)) = y \\
    F (x \meet y) = F(x) \meet F(y) \\
    G (x \join y) = G(x) \join G (y)
  \end{align}

 \paragraph{A Galois connection in program analysis}

    Consider the poset of all relations (as constraints) on complete lattices, and the poset of monotone functions (as backward transfer functions) on complete lattices.
    The Galois connection $F \dashv G$ is established between them.
  \begin{center}
    \begin{tikzcd}
    (\Pow(D \times E), \subseteq) & = \Rel(D, E) \\
    (E \tomon D, \leq)  & = \Unidir(D, E)
    \arrow["F"{name=left-adj}, bend right=30, swap, from=1-1, to=2-1]
    \arrow["G"{name=right-adj}, bend right=30, swap, from=2-1, to=1-1]
    \arrow["\dashv" rotate=0, phantom, from=left-adj, to=right-adj]
    \end{tikzcd}
  \end{center}
  where $D$ and $E$ are complete lattices of data-flow values corresponding entry and exit point of some program. The left and right adjoint $F$, $G$ are given as follows:
  \begin{align*}
    F(R) &= \lambda e_{0} . \bigjoin \{ d \mid \exists e. e \leq e_{0}  \land (d , e) \in R \} \\
    G(\fb) &= \{ (d , e) \mid d \leq \fb(e) \} \\
  \end{align*}

  Explicitly, $F \comp G$ and $G \comp F$ are presented as follows:
  \begin{align*}
    G(F(R)) &= \{ (d_{0},e_{0}) \mid d_{0} \leq \bigjoin \{ d \mid \exists e.e \leq e_{0} \land (d,e) \in R \}\} \\
    F(G(\fb)) &= \lambda e_{0} . \bigjoin \{ d \mid \exists e. e \leq e_{0} \land d \leq \fb(e) \} = \fb
  \end{align*}

\paragraph{The class of relations via the Galois connection}
  The image of $G$ is the class of relations that can be specified by backward transfer functions.
  This class of relations is equivalent to the condition being a fixed point of the Galois connection i.e, a relation $R$ satisfies $G(F(R)) = R$. Since any relation is a postfixed point ($R \subseteq G(F(R))$) by nature of Galois connections, the class of relations also equivalent to the condition of relation $R$ being a prefixed point $G(F(R)) \subseteq R$.
  We obtain the characterization of the class from general facts about Galois connection:
  \begin{proposition}\label{prop:predown-postup}
  $R$ is in the image of $G$ if and only if $R$ is $\join$-closed and $R$ is pre-down-/post-upclosed,
  where $R$ is pre-down-/post-upclosed if and only if the condition
  \begin{align*}
  \forall d\ e\ d_{1 }\ e_{0}. d \leq d_{1} \land e_{0} \leq e \land (d_{1}, e_{0}) \in R \implies (d, e) \in R
  \end{align*}
  is met.
  The following diagram represents pre-down-/post-upclosedness:
  \begin{center}
  \begin{tikzcd}
    d_{1} &       \\
    d     & e     \\
          & e_{0}
    \arrow["\rotleq"{name=dd1'}, from=2-1, to=1-1]
    \arrow["\rotleq"{name=e0e'}, from=3-2, to=2-2, swap]
    \arrow[""{name=r10'}, from=1-1, to=3-2, no head]
    \arrow[""{name=r'}, from=2-1, to=2-2, dashed, no head]
  \end{tikzcd}
  \end{center}
  \end{proposition}


  \begin{example}
    The pre-down-/post-upclosed condition fits in pre-condition weakening and post-condition strengthening in Hoare logic: $L$ is for a set of live variables and the order $\leq$ is the set inclusion $\supseteq$.
    For example, a triple $\{ L \backslash \{ x \} \} x = 10 \{ L \}$ is valid (relation is functional but the logic is still valid when replacing precondition with any $L' \supseteq L \{ x \}$ and postcondition with any $L'' \subseteq L$.
  \end{example}

  Note that the image of $F$, equivalently the fixedpoint of $F \comp G$, coinsides $\Unidir(D , E)$ itself. This follows from $F (G (\fb))) = \fb$.

  \begin{proposition}\label{prop:interior-op}
  $\fb$ is in the image of $F$ if and only if $\fb$ is an interior operation,
  where $\fb$ is interior operation if and only if $\fb$ satisfies the following condition
  \begin{align*}
    \fb(e) \leq  e \sqcap \fb (\fb e)).
  \end{align*}
  \end{proposition}

  We introduce \emph{completeness} and \emph{soundness} for operations on functions with regard to some operation on relations.
  \begin{definition}[Completeness]
   A binary operation $\otimes$ on backward transfer functions is \emph{complete} with regard to $*$ on binary operation on relations if and only if for every relation $R \in G(\fb) * G(\gb)$, $R$ is also $G (\fb \otimes \gb)$, i.e, $G(\fb) * G(\gb) \subseteq G (\fb \otimes \gb)$.
  \end{definition}

  \begin{definition}[Soundness]
  A binary operation $\otimes$ on backward transfer functions is \emph{sound} with regard to $*$ on binary operation on relations if and only if
  $G (\fb \otimes \gb) \subseteq G(\fb) * G(\gb)$
  \end{definition}

  We chose these terminology solution
  \paragraph{Operation Lifting}
  For a given binary operation $*$ on relations, a lifted binary operation $\starlift$ on backward transfer functions can be obtained by $F \dashv G$ as follows:
  \begin{align*}
  \fb \starlift \gb = F (G(\fb) * G(\gb))
  \end{align*}
  Any lifted operation $\starlift$ is complete with regard to $*$:
  \begin{align*}
  G(\fb) * G(\gb) \subseteq G(F(G(\fb) * G(\gb))) = G(\fb \starlift \gb)
  \end{align*}


\paragraph{Composition lifting via Galois connection}


  Sequencing of constraints
    The constraint corresponds to the sequential composition is the relational composition $\bowtie$ of the constraints of first and second pieces of code.

    By Using $F \dashv G$, the lifted composition of transfer functions $\bowtielift$ is obtained, which is identical to the ordinary function composition $\comp$ in the end.
    \begin{align*}
      \cdot \bowtielift \cdot &: \left| \Unidir(C, D) \right| \times  \left| \Unidir(D, E) \right| \to  \left| \Unidir(C, E) \right| \\
      (\fb \bowtielift \gb) (e_{0}) &= F(G(\fb) \bowtie G(\gb)) (e_{0}) \\
                                  &= \bigjoin \{ c \mid \exists d\, e.\,e \leq e_{0} \land c \leq \fb(d) \land d \leq \gb(e) \} \\
                                  &= \pi_{1} (\bigjoin \{ (c, d , e) \mid e \leq e_{0} \land c \leq \fb(d) \land d \leq \gb(e) \}) \\
                                  &= (\fb \comp \gb)(e_{0})
    \end{align*}

  \paragraph{Composition lifting via Galois connection}

  Non-deterministic choice of constraints
    The constraint corresponding to the non-deterministic choice of programs is the intersection $\cap$ of choices.
 Lifting of composition in poset of backward transfer functions
    Similarly to the sequential composition, we get choice operation $\caplift$ on backward transfer functions which is identical to $\meet$ pointwisely.
    \begin{align*}
      \cdot \caplift \cdot &: \left| \Unidir(D , E) \right| \times  \left| \Unidir(D, E) \right| \to \left| \Unidir(D, E) \right| \\
      (\fb \caplift \gb) (e_{0})
      &= F(G(\fb) \cap G(\gb)) (e_{0}) \\
      &= (F(G(\fb) \meet F(G(\fb))) (e_{0}) \\
      &= \bigjoin \{ d \mid \exists e\,. e \leq e_{0} \land d \leq \fb(e) \} \\ &\quad \meet \bigjoin \{ d \mid \exists e\,. e \leq e_{0} \land d \leq \gb(e) \} \\
      &= \fb(e_{0}) \meet \gb(e_{0})
    \end{align*}


  \paragraph{Soundness and Completeness}
  The following equalities
  \begin{itemize}
    \item $G(\fb) \bowtie G(\gb) = G(\fb \comp \gb)$
    \item $G(\fb) \cap G(\fb) = G(\fb \meet \gb)$
  \end{itemize}
  validate the soundness and completeness of backward (and forward, by symmetry) data-flow analysis within the image of $G$.  This illustrates how the algorithm for data-flow analysis work:


  Example: Live variable analysis
   \begin{center}
  \begin{tikzpicture}[auto]
    \node[term] at (0, 0.0) (entry) {\emph{entry}};
    \node[block] at (2, 0.0) (s1) {$\scriptstyle{x := 10}$};
    \node[block] at (4, 0.5) (s2)   {$\scriptstyle{x := 40}$};
    \node[block] at (4, -0.5) (s3)   {$\scriptstyle{\mathit{print}(x)}$};
    \node[term] at (6, 0.0) (exit)  {\emph{exit}};
    \draw [arrow] (entry) -- (s1);
    \draw [arrow] (s1) -- (s2);
    \draw [arrow] (s1) -- (s3);
    \draw [arrow] (s3) -- (exit);
    \draw [arrow] (s2) -- (exit);
    \node[block] at (2, -0.3) (load0) {$\scriptscriptstyle{L \setminus \{ x \} \mapsfrom L }$};
    \node[block] at (3, 0) (entry) {$\scriptscriptstyle{\bigcup}$};
    \node[block] at (4, 0.2) (pop)   {$\scriptscriptstyle{L \setminus \{ x \} \mapsfrom L }$};
    \node[block] at (4, -0.8) (store)   {$\scriptscriptstyle{L \cup \{ x \} \mapsfrom L}$};
  \end{tikzpicture}
  \end{center}

  where the domain of data-flow values is a set of live variables $\{\emptyset, \{ x \}\}$, and $\meet$ is the set union $\cup$.

\section{Bidirectional data-flow analyses}  

  \paragraph{Bidirectional Data-Flow Analysis}
  Sometimes, analyzing data-flow in both backward and forward directions is necessary. This is known as \emph{bidirectional data-flow analysis}.


  Examples
  \begin{itemize}
    \item Partial redundancy elimination
    \item Type inference for a dynamically typed language
    \item Load-pop pair elimination for stack-based language
  \end{itemize}
  Based on our insights from the unidirectional analysis, it make sense to investigate the Galois connection, the associated class of relations, and the behavior of program compositions in the context of bidirectional data-flow analysis.

  \paragraph{The Galois Connection for Bidirectional Transfer Functions}
  The Galois connections $H \dashv I$ , $J \dashv K$ and $P \dashv M$ are established among the relational constraints, endo monotone functions on product lattice, the bidirectional transfer functions, and the backward unidirectional functions. These factor through $F \dashv G$ by $(P \comp J \comp H) \dashv (I \comp K \comp M)$.
  \begin{center}
    \begin{tikzcd}
      (\Pow(D \times E), \subseteq) & = \Rel(D, E) \\
      ((D \times E) \tomon (D \times E) , \leq) & = \Endo(D, E) \\
      ((E \tomon D) \times (D \tomon E) , \leq) & = \Bidir(D, E) \\
      (E \tomon D , \leq) & = \Unidir(D, E)
        \arrow["H"{name=H}, bend right=30, swap, from=1-1, to=2-1]
        \arrow["I"{name=I}, bend right=30, swap, from=2-1, to=1-1]
        \arrow["J"{name=J}, bend right=30, swap, from=2-1, to=3-1]
        \arrow["K"{name=K}, bend right=30, swap, hook, from=3-1, to=2-1]
        \arrow["P"{name=P}, bend right=30, swap, from=3-1, to=4-1]
        \arrow["M"{name=M}, bend right=30, swap, hook, from=4-1, to=3-1]
        \arrow["\dashv", phantom, from=H, to=I]
        \arrow["\dashv", phantom, from=J, to=K]
        \arrow["\dashv", phantom, from=P, to=M]
    \end{tikzcd}
  \end{center}
  The monotone functions consists of the Galois connections are given as follows:
  \begin{align*}
    H &: \Rel \tomon \Endo &
    I &: \Endo \tomon \Rel \\
    H(R) &= \lambda p_{0} . \bigjoin (\downarrow p_{0} \cap R) &
    I(f) &= \{p \mid p \leq f(p)\} \\
    J &: \Endo \tomon \Bidir &
    K &: \Bidir \tomon \Endo \\
    J(f) &= (\lambda e . f (\top , e ) , \lambda d . f (d , \top)) &
    K(\fb , \ff) &= \lambda (d , e) . (\fb(e) , \ff(d)) \\
    P &: \Bidir \tomon \Unidir &
    M &: \Unidir \tomon \Bidir \\
    P(\fb , \ff) &= \fb &
    M(\fb) &= (\fb , \top)
  \end{align*}

  The image of $I$, i.e, all prefixed-points of $I \comp H$, is characterized by $\join$-closedness:
  \begin{theorem}\label{thm:join-closed}
    A relation $R$ is in the image of $I$ if and only if $R$ is $\join$ \text{-closed}
  \end{theorem}


  By pre-composing with any monotone function to $I$, the image becomes restricted.
  \begin{proposition} \label{pr:restriction-subset}
    Given any monotone function $I'$ whose codomain is $\Endo(D, E)$, the image of $I \comp I'$ is included by the image of $I$.
    Hence, if a relation $R$ is in the image of $I \comp I'$ then $R$ is $\join$-closed.
  \end{proposition}
  Specifically, all relations in the image of $I \comp K$ and of $I \comp K \comp M$ are $\join$-closed.

  % we need to add Endo condition
  % expansion of lifting
  % expansion of composition of H I. etc
  \paragraph{The Class of Relations for Bidirectional Flow -- Butterfly}
  The image of $H$, the class of relations represented by a bidirectional function pair, is characterized by relation $R$ being $\join$-closed and has a property called \emph{butterfly}.

  \begin{definition}[Butterfly relation]
    A relation $R$ is \emph{butterfly} if and only if \begin{align*}
      &\forall d\, e\, d_{0}\, d_{1 }\, e_{0}\, e_{1} .
      d_{0} \leq d \leq d_{1} \land e_{0} \leq e \leq e_{1} \land (d_{1}, e_{0}) \in R \land (d_{0}, e_{1}) \implies (d, e) \in R,
    \end{align*}or diagramatically, \quad
  \begin{tikzcd}
    d_{1} & e_{1} \\
    d     & e     \\
    d_{0} & e_{0}
    \arrow["\rotleq"{name=d0d'}, from=3-1, to=2-1]
    \arrow["\rotleq"{name=dd1'}, from=2-1, to=1-1]
    \arrow["\rotleq"{name=ee1'}, from=2-2, to=1-2, swap]
    \arrow["\rotleq"{name=e0e'}, from=3-2, to=2-2, swap]
    \arrow[""{name=r01'}, from=3-1, to=1-2, no head]
    \arrow[""{name=r10'}, from=1-1, to=3-2, no head]
    \arrow[""{name=r'}, from=2-1, to=2-2, dashed, no head]
  \end{tikzcd}
  \end{definition}

  \paragraph{Composition and Butterfly property -- A Case of Failure}
  The \emph{butterfly} property of relations is closed under $\cap$ but \red{not} closed under $\bowtie$.

  Counterexample
  A pair of butterflies $R$ and $S$ such that the composition $R \bowtie S$ is not a butterfly:
  \begin{center}
    \begin{tikzcd}
          &      \\
          & d_{1}\\
    c_{0} & d_{0}
    \arrow["\rotleq"{name=d0d1}, from=3-2, to=2-2, swap]
    \arrow["R"{name=r00}, from=3-1, to=3-2, no head, swap]
    \arrow["R"{name=r01}, from=3-1, to=2-2, no head]
    \end{tikzcd}
    $\bowtie$
    \begin{tikzcd}
          & e_{2} \\
    d_{1} & e_{1} \\
    d_{0} & e_{0}
    \arrow["\rotleq"{name=d0d1'}, from=3-1, to=2-1]
    \arrow["S"{name=s00}, from=3-1, to=3-2, no head, swap]
    \arrow["S"{name=s01}, from=2-1, to=1-2, no head]
    \arrow["\rotleq"{name=e0e1'}, from=3-2, to=2-2, swap]
    \arrow["\rotleq"{name=e1e2'}, from=2-2, to=1-2, swap]
    \end{tikzcd}
    $\quad=\quad$
    \begin{tikzcd}
          & e_{2} \\
          & e_{1} \\
    c_{0} & e_{0}
    \arrow["R \bowtie S"{name=rs0}, from=3-1, to=3-2, no head, swap]
    \arrow["/" marking, from=3-1, to=2-2, dashed, no head, gray]
    \arrow["R \bowtie S"{name=rs1}, from=3-1, to=1-2, no head]
    \arrow["\rotleq"{name=e0e1'}, from=3-2, to=2-2, swap]
    \arrow["\rotleq"{name=e1e2'}, from=2-2, to=1-2, swap]
    \end{tikzcd}
  \end{center}
  Not having the gray dashed line violates being butterfly.


  The \emph{butterfly} property of relations is closed under $\cap$ but \red{not} closed under $\bowtie$.
  The situation tells us, while we can explicitly give a sequencing operation for bidirectional transfer function as
  \begin{equation*}
    (\fb,\ff) \bowtielift (\gb,\gf) = I(H((\fb, \ff)) \bowtie H((\gb , \gf))),
  \end{equation*}
  The outcome is only guaranteed to be an overapproximation and it may not be sound (underapproximation).
  $H(\fb, \ff) \bowtie H(\gb, \gf) \subseteq H((\fb, \ff) \bowtielift (\gb, \gf))$


  In the context of analysis of load-pop pairs for stack-based language,
  we have found the case: The sequential composition $\binop; \pop$ is not butterfly while both $\binop$ and $\pop$ are butterfly.
  \begin{figure}
  \begin{tikzcd}[column sep=tiny]
               & \opt,\opt,xs & \quad &          \\
  \opt,\mnd,xs & \mnd,\opt,xs & & \opt, xs \\
               & \mnd,\mnd,xs & & \mnd, xs
  \arrow["\leq", from=3-2, to=2-1, swap, sloped]
  \arrow["\leq", from=3-2, to=2-2, swap, sloped]
  \arrow["\leq", from=2-1, to=1-2, sloped]
  \arrow["\leq", from=2-2, to=1-2, sloped]
  \arrow["\leq", from=3-4, to=2-4, sloped]
  \arrow["", from=3-2, to=3-4, no head, swap]
  \arrow["", from=1-2, to=2-4, no head, swap]
  \end{tikzcd}
  \begin{tikzcd}[column sep=tiny, row sep=small]
           & \quad & \\
  \opt, xs & & \\
  \mnd, xs & & xs
  \arrow["\leq", from=3-1, to=2-1, swap, sloped]
  \arrow["", from=3-1, to=3-3, no head, swap]
  \arrow["", from=2-1, to=3-3, no head, swap]
  \end{tikzcd}
  \caption{The constraints for the instructions $\binop$ (left) and $\pop$ (right)}
  \end{figure}

  \begin{figure}
  \begin{tikzcd}[column sep=tiny, row sep=small]
               & \opt,\opt,xs & \quad &          \\
  \opt,\mnd,xs & \mnd,\opt,xs & &          \\
               & \mnd,\mnd,xs & & xs
  \arrow["\leq", from=3-2, to=2-1, swap, sloped]
  \arrow["\leq", from=3-2, to=2-2, swap, sloped]
  \arrow["\leq", from=2-1, to=1-2, sloped]
  \arrow["\leq", from=2-2, to=1-2, sloped]
  \arrow["", from=3-2, to=3-4, no head, swap]
  \arrow["", from=1-2, to=3-4, no head, swap]
  \end{tikzcd}
  \caption{The constraint for $\binop;\pop$, missing gray lines violates butterfly}
  \end{figure}

  \paragraph{Implications for Bidirectional Flow Analysis}
  A sequence of instructions $i_{1};i_{2}\cdots;i_{n}$ without any branch in/out except for entry/exit is called a \emph{basic block}.


  In Unidirectional Flow Analysis
    Traditionally, each basic block in a program is treated as a single node in the flow graph.
 
  In Bidirectional Flow Analysis
    \red{Cannot} put a basic block into a single node naively.

  This is because composition of two bidirectional function pairs would introduce constraint that is not captured by a single bidirectional function pair. Treating each instruction as an individual node is a safe option but has drawbacks in terms of the efficiency of the analysis.


%    In traditional data-flow analysis, we use basic blocks as building blocks. A basic block is a sequence of instructions with only one entry and one exit. In unidirectional analysis, we can usually put these sequence together into a single node in the flow graph. But, in bidirectional analysis, we cannot do so naively because the composition of two bidirectional function pair would introduce constraints that is not captured by single bidirectional function pair.

% 
%  \paragraph{Solution 1 -- $n$-tupling}
%  A simple solution to this is to stop consolidating basic blocks into a single node and instead treat each instruction as one node.

%   In this approach, the constraints arise from a basic block consists of $n-1$ instructions are treated as an element of $n$-ary relations $\Pow(D_{1} \times D_{2} \times  \cdots  \times D_{n})$, and within the basic block, the carriers of data flow values become $(n-1)$-tuples of pairs of monotone functions $((D_{1} \tomon D_{2}) \times (D_{2} \tomon D_{1}) \times \cdots \times (D_{n-1} \tomon D_{n}) \times (D_{n} \tomon D_{n-1}))$.
%
%   The soundness of lifted operations still holds for the Galois connection between those posets but compositionality is somewhat broken in that intermediate program points cannot be hidden in sequential composition.
% 

  \paragraph{A Remedy -- Narrowing the class of relations }
  The poset of $((E \tomon D) \times E, \leq) = \UnidirConst(D, E)$ locates between $\Bidir(D , E)$ and $\Unidir(D , E)$.
  The Galois connection $\langle \pi_{1}, \bigjoin \rangle \dashv \langle {\mathrm{id}, \mathrm{const}}\rangle$ and $ \pi_{1} \dashv \langle {\mathrm{id}} , \top \rangle)$ is established and factors $P \dashv M$.
  \begin{center}
    \begin{tikzcd}
      (\Pow(D \times E), \subseteq) & = \Rel(D, E) \\
      ((E \tomon D) \times (D \tomon E) , \leq) & = \Bidir(D, E) \\
      ((E \tomon D) \times E, \leq) & = \UnidirConst(D, E) \\
      (E \tomon D , \leq) & = \Unidir(D, E)
        \arrow["J \comp H"{name=H}, bend right=30, swap, from=1-1, to=2-1]
        \arrow["I \comp K"{name=I}, bend right=30, swap, from=2-1, to=1-1]
        \arrow["\langle {\pi_{1}, \bigjoin } \rangle"{name=J}, bend right=30, swap, from=2-1, to=3-1]
        \arrow["\langle {\mathrm{id}, \mathrm{const}}\rangle"{name=K}, bend right=30, swap, hook, from=3-1, to=2-1]
        \arrow["\pi_{1}"{name=M}, bend right=30, swap, from=3-1, to=4-1]
        \arrow["\langle {\mathrm{id}, \top} \rangle"{name=N}, bend right=30, swap, hook, from=4-1, to=3-1]
        \arrow["\dashv", phantom, from=H, to=I]
        \arrow["\dashv", phantom, from=J, to=K]
        \arrow["\dashv", phantom, from=M, to=N]
    \end{tikzcd}
  \end{center}
  Indeed, the class of relations corresponds to the Galois connection between $\Rel(D, E)$ and $\UnidirConst(D, E)$ is closed under both $\cap$ and $\bowtie$.


  \paragraph{The class of relations for $\UnidirConst$}
  The class of relation corresponding to the Galois connection $(\langle {\pi_{1}, \bigjoin } \rangle \comp H)  \dashv (I \comp \langle {\mathrm{id}, \mathrm{const}}\rangle)$
  is characterized by conjunction of the conditions
  ($\forall d\, d_{1}\, e.\, d \leq d_{1} \land (d_{1}, e) \in R \implies (d , e) \in R$ and $\forall d\, e_{0}\, e_{1}\, e.\, e_{0} \leq e \leq e_{1} \land (d, e_{0}) \in R \land (d, e_{1}) \in R \implies (d , e) \in R$)
  represented by the following two diagrams together with $\join$-closedness.
  \begin{center}
  \begin{tikzcd}
    d_{1} &  \\
    d     & e \\
    \arrow["\rotleq"{name=dd1'}, from=2-1, to=1-1]
    \arrow[""{name=r10'}, from=1-1, to=2-2, no head]
    \arrow[""{name=r'}, from=2-1, to=2-2, dashed, no head]
  \end{tikzcd}
  \begin{tikzcd}
      & e_{1} \\
    d & e     \\
      & e_{0}
    \arrow["\rotleq"{name=ee1'}, from=2-2, to=1-2, swap]
    \arrow["\rotleq"{name=e0e'}, from=3-2, to=2-2, swap]
    \arrow[""{name=r01'}, from=2-1, to=1-2, no head]
    \arrow[""{name=r10'}, from=2-1, to=3-2, no head]
    \arrow[""{name=r'}, from=2-1, to=2-2, dashed, no head]
  \end{tikzcd}
  \end{center}

\section{Conclusion}

\begin{itemize}
    \item Galois connection in Program analyses
    \begin{itemize}
      \item Bridge between data-flow analysis and its relational aspects
      \item Gives a nice characterization of the class of relations underlying data-flow analysis
      \item Provides operations for program compositions ($\bowtielift$, $\caplift$) in $\Unidir(D, E)$, automatically
    \end{itemize}
    \item Bidirectional Data-flow analysis
    \begin{itemize}
      \item The class of relations is characterized by using butterfly property
      \item Composing two butterflies may be a non-butterfly!
      \item Having problem with the traditional `basic blocks as a single node` approach in $\Bidir(D, E)$
    \end{itemize}
    \item A Remedy for Compositionality in Bidirectional Flow
    \begin{itemize}
      \item By limiting one direction to be constant flow, $\UnidirConst(D, E)$ gains compositionality again.
    \end{itemize}
  \end{itemize}



\nocite{*}  % just to see all we have in the bib file
  
\bibliographystyle{splncs04}
\bibliography{ramics24}  

\appendix
\section{Proofs}
\subsection{Proof of Proposition \ref{prop:predown-postup}}
The proof is formed by establishing the following three facts:
\begin{enumerate}[i.]
\item{$R$ is in the image of $G$ $\implies$ $R$ is pre-down-/post-upclosed:}\\
  The proposition is proved in the following steps:
  \begin{align*}
    R \text{ is in the image of } G \iff \\
    G(F(R)) \subseteq R \iff \\
    (\forall d\, e . d \leq \bigjoin \{ d' \mid \exists e' \leq e \land (d', e') \in R \} \implies (d , e) \in R) \implies \tag{*}\label{eqv:proof-pre-down-post-upclosed} \\
    \forall d\ e\ d_{1 }\ e_{0}. d \leq d_{1} \land e_{0} \leq e \land (d_{1}, e_{0}) \in R \implies (d, e) \in R \iff \\
    R \text{ is pre-down-/post-upclosed }.
  \end{align*}
  We prove the nontrivial implication on the step (\ref{eqv:proof-pre-down-post-upclosed}).
  Suppose $d \leq d_{1}$, $e_{0} \leq e$, and $(d_{1} , e_{0}) \in R$.
  The point $(d_{1} , e_{0})$ is in the set $\downarrow (\top , e) \cap R$, and we get
  $d \leq d_{1}  \leq \pi_{1} (\bigjoin (\downarrow (\top , e) \cap R)) = \bigjoin \{ d' \mid \exists e' \leq e \land (d', e') \in R \}$
  by using transitivity and properties of $\bigjoin$.
  From the condition $d \leq \bigjoin \{ d' \mid \exists e' \leq e \land (d', e') \in R \}$ and the premise $(\forall d\, e . d \leq \bigjoin \{ d' \mid \exists e' \leq e \land (d', e') \in R \} \implies (d , e) \in R)$, we conclude $(d , e) \in R$.
\item{$R$ is in the image of $G$ $\implies$ $R$ is $\join$-closed:}\\
  Recall $G = I \comp K \comp M$. It follows immediately from Proposition \ref{pr:restriction-subset}.
\item{$R$ is $\join$-closed $\land$ $R$ is pre-down/post-upclosed $\implies$ $R$ is in the image of $G$:}\\
  Let $(d, e)$ be a point in $D \times E$ such that $d \leq \bigjoin \{d' \mid \exists e' \leq e \land (d' , e') \in R \}$.
  Use pre-down-/post-upclosedness of $R$ by assigning $(d_{1}, e_{0}) = \bigjoin (\downarrow (\top , e) \cap R)$.
  From the assumption, we have $d \leq \bigjoin \{d' \mid \exists e' \leq e \land (d' , e') \in R \} = \pi_{1} (\bigjoin (\downarrow (\top , e) \cap R)) = d_{1} $.
  It is obvious that for every $p \in \downarrow (\top , e) \cap R$, $p \leq (\top , e)$, and we conclude $e_{0} = \pi_{2} (\bigjoin (\downarrow (\top , e) \cap R)) \leq e$ from property of $\bigjoin$.  By using $\join$-closedness of $R$ for the subset $(\downarrow (\top , e) \cap R) \subseteq R$, we have $(d_0 , e_0) = \bigjoin (\downarrow (\top , e) \cap R) \in R$.
  Given the conjunction of $d \leq d_{1}$, $e_{0} \leq e$ and $(d_{1} , e_{0}) \in R$, the premise results $(d, e) \in R$
\end{enumerate}
Therefore, by proving the above propositions, we have shown that $R$ is in the image of $G$ if and only if $R$ is $\join$-closed and $R$ is pre-down-/post-upclosed.


\subsection{Proof of Theorem \ref{thm:join-closed}}
The proof is carried out in the following steps:
\begin{align*}
 R \text{ is in the image of } I &\iff \\
 I(H(R)) \subseteq R &\iff \\
  \{ p_{0} \mid p_{0} \leq \bigjoin (\downarrow p_{0} \cap R) \} \subseteq R &\iff \tag{*}\label{eq:IH-characterization}\\
\forall S \subseteq R, \bigjoin S \in R &\iff \\
R \text{ is }\join \text{-closed }
\end{align*}
The nontrivial logical equivalence on the step (\ref{eq:IH-characterization}) is proved as follows:
\begin{enumerate}[i.]
\item{$ \{ p_{0} \mid p_{0} \leq \bigjoin (\downarrow p_{0} \cap R) \} \subseteq R \implies \forall S \subseteq R, \bigjoin S \in R$}:\\
Let $S$ be a subset of $R$. Combining the facts $\forall p \in S. p \leq \bigjoin S (\iff S \subseteq \downarrow (\bigjoin S)$ and $S \subseteq R$, we obtain $S \subseteq (\bigjoin S) \cap R)$ . By using monotonicity of $\bigjoin$, we get $\bigjoin S \leq \bigjoin (\downarrow (\bigjoin S) \cap R)$. Therefore, $\bigjoin S \in \bigjoin (\downarrow (\bigjoin S) \cap R) \subseteq R$.

\item{$ \{ p_{0} \mid p_{0} \leq \bigjoin (\downarrow p_{0} \cap R) \} \subseteq R \impliedby \forall S \subseteq R, \bigjoin S \in R$:}\\
Let $p_0$ be an arbitrary point such that $p_{0} \leq \bigjoin (\downarrow p_{0} \cap R) \}$.
From the subset relation $\downarrow p_{0} \cap R \subseteq \downarrow p_{0}$ and monotonicity of $\bigjoin$, we get $\bigjoin (\downarrow p_{0} \cap R) \leq \bigjoin (\downarrow p_{0}) = p_{0}$. From anti-symmetry of $\leq$, we get $p_{0} = \bigjoin (\downarrow p_{0} \cap R) \}$.
Giving $\downarrow p_{0} \cap R$ for $S$ in the premise results $\bigjoin (\downarrow p_{0} \cap R) \in R$. Since $p_{0} = \bigjoin (\downarrow p_{0} \cap R) \}$, we get $p_{0} \in R$.
\end{enumerate}

The other steps are proved by definition or by using a general property of the Galois connection $H \dashv I$.
There fore we have shown that $R$ is in the image of $G$ if and only if $R$ is $\join$-closed and $R$ is pre-down-/post-upclosed.
\qed

\subsection{Proof of Proposition \ref{prop:interior-op}}
The proof is carried out into the following steps:
\begin{align*}
 f \text{ is in the image of } H &\iff \\
 f \leq H(I(\fb)) &\iff \\
 \forall p. f(p) \leq \bigjoin (\downarrow p \cap (\{p' \mid p' \leq f(p') \})) &\iff \\
 \forall p. f(p) \leq \bigjoin (\{p' \mid p' \leq  p \meet f(p') \})) &\iff \\
 \forall p. f(p) \leq \nu p' . p \sqcap f(p') &\iff \tag{*}\label{eq:interior-iso}\\
 \forall p. f(p) \leq p \sqcap f(f(p)) &\iff \\
 \fb \text{ is an interior operator}
\end{align*}

We prove $\forall p.\nu p' . p \sqcap f(p') = p \sqcap f(f(p))$ to validate the step (\ref{eq:interior-iso}).

\begin{enumerate}[i.]
\item{Proof of $(\forall p. f(p) \leq \nu p' . p \sqcap f(p')) \implies (\forall p. f(p) \leq p \sqcap f(f(p)))$:}\\
Let $p$ be an arbitrary point of $D \times E$, and $p_{*} = \nu p' . p \sqcap f(p')$.
Then it is enough to show that $p_{*} \leq p \sqcap f(f(p))$ holds. This is done by unfolding $\nu$ in the definition of $p_{*}$ several times, and tne using monotonicity to forget the effects of some subterms.
\begin{align*}
p_{*} & = p \meet f(p_{*}) = p \meet f(p \meet f(p_{*})) = p \meet (f (p \meet f(p \meet f(p_{*})))) \\
     & \leq p \meet (f (\top \meet f(p \meet \top))) = p \meet (f (f (p)))
\end{align*}
\item{Proof of $(\forall p. f(p) \leq \nu p' . p \sqcap f(p')) \impliedby (\forall p. f(p) \leq p \sqcap f(f(p)))$:}\\
Let $p$ be an arbitrary point of $D \times E$, and $p_{*} = \nu p' . p \sqcap f(p')$.
\end{enumerate}




\end{document}


Galois connections:


             G
Rel   <-------------  Bwd
            T
      -------------->
            F


       I            K             M
Rel   <---  Endo   <---- Bidir  <----  Bwd
      ---->        ---->        ----->
       H            J             L


